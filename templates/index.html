<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>UR10e â€” Joints + FK Visuals</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <style>
    html,body{width:100%;height:100%;margin:0;overflow:hidden}
    #renderCanvas{width:100%;height:100%;touch-action:none}
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>
  <script>
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);

    // Forward any query params (like ?shoulder_pan_joint=1.0) to both APIs
    const JOINT_PARAMS = location.search || "";

    async function getJSON(url){ const r = await fetch(url); if(!r.ok) throw new Error(url+" -> "+r.status); return r.json(); }

    function fitCameraToMeshes(scene, camera, meshes) {
      if (!meshes.length) return;
      let min = meshes[0].getBoundingInfo().boundingBox.minimumWorld.clone();
      let max = meshes[0].getBoundingInfo().boundingBox.maximumWorld.clone();
      for (let i = 1; i < meshes.length; i++) {
        const bb = meshes[i].getBoundingInfo().boundingBox;
        min = BABYLON.Vector3.Minimize(min, bb.minimumWorld);
        max = BABYLON.Vector3.Maximize(max, bb.maximumWorld);
      }
      const center = min.add(max).scale(0.5);
      const size = max.subtract(min);
      const radius = Math.max(size.x, size.y, size.z) * 1.25;
      camera.setTarget(center);
      camera.radius = Math.max(radius, 0.5);
    }

    (async function(){
      const scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color3(0.1,0.1,0.15);
      scene.useRightHandedSystem = true;

      const camera = new BABYLON.ArcRotateCamera("cam", Math.PI/2, Math.PI/3, 2.5, BABYLON.Vector3.Zero(), scene);
      camera.attachControl(canvas, true);
      new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0,1,0), scene);

      new BABYLON.AxesViewer(scene, 0.3);

      const drawn = [];

      // 1) Draw joints + skeleton
      const jointsData = await getJSON("/api/joints" + JOINT_PARAMS);
      jointsData.joints.forEach(j=>{
        const s = BABYLON.MeshBuilder.CreateSphere("joint_"+j.name,{diameter:0.03},scene);
        s.position = new BABYLON.Vector3(...j.position);
        drawn.push(s);
      });
      jointsData.edges.forEach(e=>{
        const line = BABYLON.MeshBuilder.CreateLines("edge_"+e.from+"_"+e.to,{points:[
          new BABYLON.Vector3(...e.p1),
          new BABYLON.Vector3(...e.p2)
        ]},scene);
        line.color = new BABYLON.Color3(1,1,0);
        drawn.push(line);
      });

      // 2) Load OBJs at FK poses (position + quaternion)
      const { baseUrl, visuals } = await getJSON("/api/visuals" + JOINT_PARAMS);
      const loadedMeshes = [];
      for (const v of visuals) {
        await new Promise(resolve => {
          BABYLON.SceneLoader.ImportMesh("", baseUrl, v.mesh, scene,
            meshes => {
              meshes.forEach(m => {
                m.position = new BABYLON.Vector3(v.position[0], v.position[1], v.position[2]);
                m.rotationQuaternion = new BABYLON.Quaternion(
                  v.quaternion[0], v.quaternion[1], v.quaternion[2], v.quaternion[3]
                );
                m.scaling = new BABYLON.Vector3(v.scale, v.scale, v.scale);

                // Simple gray if no material
                if (!m.material) {
                  const mat = new BABYLON.StandardMaterial("mat_"+v.link, scene);
                  mat.diffuseColor = new BABYLON.Color3(0.75, 0.75, 0.75);
                  m.material = mat;
                }
                loadedMeshes.push(m);
              });
              resolve();
            },
            null,
            (_s, msg)=>{ console.error("OBJ load error", v.mesh, msg); resolve(); }
          );
        });
      }

      fitCameraToMeshes(scene, camera, [...drawn, ...loadedMeshes]);

      engine.runRenderLoop(()=>scene.render());
      window.addEventListener("resize", ()=>engine.resize());
    })();
  </script>
</body>
</html>
